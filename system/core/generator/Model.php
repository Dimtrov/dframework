<?php
/**
 * dFramework
 *
 * The simplest PHP framework for beginners
 * Copyright (c) 2019 - 2021, Dimtrov Lab's
 * This content is released under the Mozilla Public License 2 (MPL-2.0)
 *
 * @package     dFramework
 * @author      Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>
 * @copyright   Copyright (c) 2019 - 2021, Dimtrov Lab's. (https://dimtrov.hebfree.org)
 * @copyright   Copyright (c) 2019 - 2021, Dimitri Sitchet Tomkeu. (https://www.facebook.com/dimtrovich)
 * @license     https://opensource.org/licenses/MPL-2.0 MPL-2.0 License
 * @link        https://dimtrov.hebfree.org/works/dframework
 * @version     3.4.1
 */

namespace dFramework\core\generator;

use dFramework\core\db\connection\BaseConnection;
use dFramework\core\db\Database;
use RuntimeException;
use dFramework\core\dFramework;
use Nette\PhpGenerator\ClassType;
use dFramework\core\utilities\Str;
use Nette\PhpGenerator\PhpNamespace;
use dFramework\core\models\Model as CoreModel;
use dFramework\core\support\traits\CliMessage;
use Nette\PhpGenerator\Method;
use Nette\PhpGenerator\Parameter;

/**
 * generator\Model
 *
 * Generate a file for model class
 *
 * @package     dFramework
 * @subpackage  Core
 * @category    Generator
 * @author      Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>
 * @link        https://dimtrov.hebfree.org/docs/dframework/api
 * @since       3.4.1
 * @file        /system/core/generator/Model.php
 */
final class Model
{
    use CliMessage;

    /**
     * @var bool Specifie si le fichier doit etre vide ou pas
     */
    private $empty = false;
    /**
     * @var string Classe a generer
     */
    private $class = '';
    /**
     * @var string Nom complet de la classe généré (namespace y compris)
     */
    private $full_class_name = '';
    /**
     * @var string Dossier de sauvegarde
     */
    private $dir = '';

	/**
	 * @var BaseConnection
	 */
	private $connection;


    /**
     * Constructor
     *
     * @param mixed $empty
     */
    public function __construct($empty = null)
    {
        if (!empty($empty))
        {
            $this->empty = true;
        }

		helper('inflector');

		$this->connection = Database::instance()->connection();
    }


    /**
     * Demarre la generation
     *
     * @param string $class
     * @param string $dir
     * @return string
     */
    public function generate(string $class, ?string $dir = \MODEL_DIR) : string
    {
        $dir = empty($dir) ? \MODEL_DIR : $dir;
        $this->class = preg_replace('#Model$#i', '', $class);

        $this->writeProperties($dir, $render);
        $this->createFile($render);

        return $this->full_class_name;
    }

    /**
     * Ecrit les proprietes de la classe, les getters et les setters
     *
     * @param string $class
     * @param array $properties
     * @param $render
     */
    protected function writeProperties($dir, &$render)
    {
        $dir = str_replace(\MODEL_DIR, '', $dir);
        $dir = trim($dir, '/\\');
        $dir = str_replace(['/', '\\'], '/', $dir);
        $dir = rtrim($dir, '/');

        if (!empty($dir))
        {
            $namespace = new PhpNamespace(str_replace('/', '\\', $dir));
        }
        $this->dir = $dir . (empty($dir) ? '' : '/');

        $class_name = Str::toPascalCase($this->class.'Model');
        $generator = (new ClassType($class_name, $namespace ?? null))
			->addComment($class_name."\n")
			->addComment('Generated by dFramework v'.dFramework::VERSION)
			->addComment('Date : '.date('r'))
			->addComment('PHP Version : '.phpversion())
			->addComment('Model : '.preg_replace("#Model$#", '', $class_name))
			->setExtends(CoreModel::class);

        if (false === $this->empty)
        {
			$class = $this->class;
			$pks = $this->connection->indexes($this->class, 'PRIMARY');
			$pks = $pks->fields ?? [];

			/* Ajout de la methode de creation (C)*/
			$this->addCreateMethod($generator, compact('class'));

			/* Ajout de la methode de selection (R)*/
			$this->addReadMethod($generator, compact('class', 'pks'));

			/* Ajout de la methode de modification (U)*/
			$this->addUpdateMethod($generator, compact('class', 'pks'));

			/* Ajout de la methode de supression (D)*/
			$this->addDeleteMethod($generator, compact('class', 'pks'));

			/* Ajout de la methode pour compter le nombre d'elements */
			$this->addCountMethod($generator, compact('class'));
        }

        $this->full_class_name = implode('\\', [$namespace ?? '', $class_name]);

        $render = (string) $generator;
    }
    /**
     * Enregistre le code de la classe dans le fichiers
     *
     * @param $render
     */
    protected function createFile($render)
    {
        $class_name = Str::toPascal($this->class.'Model');

        $dir = str_replace(\MODEL_DIR, '', $this->dir);
        $dir = MODEL_DIR.trim($dir, '/\\');
        $dir = str_replace(['/', '\\'], DS, $dir);
        $dir = rtrim($dir, DS).DS;

        $this->dir = $dir;
        if (!is_dir($this->dir))
        {
            mkdir($this->dir);
        }
        $filename  = $this->dir.$class_name.'.php';
        $f = fopen($filename, 'w');
        if (!is_resource($f))
        {
            throw new RuntimeException('impossible de generer le modele: '.$this->class);
        }

        fwrite($f, "<?php \n".$render);
        fclose($f);
    }

	/**
     * Ajout de la methode de creation
     *
     * @param ClassType $generator
     * @return void
     */
    private function addCreateMethod(ClassType &$generator, array $variables)
    {
		/**
		 * @var string $class
		 */
        extract($variables);

        $hydrate  = "\treturn \$this->into('$class')->insert(\$data)->lastId();";

		$method = (new Method('create'))
            ->setPublic()
            ->addComment("Add 1 new ".\singular($class)." in database \n")
            ->addComment('@param array $data')
            ->addComment('@return int|null')
            ->setReturnNullable()
            ->setReturnType('int')
            ->setParameters([
                (new Parameter('data'))->setType('array')
            ])
            ->setBody($hydrate);

        $generator->addMember($method);
    }

	/**
     * Ajout de la methode de listing
     *
     * @param ClassType $generator
     * @return void
     */
	private function addReadMethod(ClassType &$generator, array $variables)
    {
		/**
		 * @var string $class
		 * @var array $pks
		 */
        extract($variables);

        $class_name = Str::toPascalCase($class.'Entity');
        $fks = $this->connection->foreignKeys($class);

    	// Liste des enregistrements
        $hydrate  = "return \$this->from('$class')->all(\$hydrate ? ".$class_name."::class : null); \n";
        $m = (new Method('readAll'))
            ->setPublic()
            ->addComment("Select all data from table ".$class." \n")
            ->addComment('@param bool $hydrate')
            ->addComment('@return stdClass[]|'.$class_name.'[]')
            ->setReturnType('array')
            ->setParameters([
                (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false)
            ])
            ->setBody($hydrate);
        $generator->addMember($m);

    	// Enregistrement unique
        $hydrate  = "return \$this->from('$class')";
        foreach ($pks As $pk)
        {
            $hydrate .= "\n\t->where('".$pk."', $".$pk.")";
        }
        $hydrate .= "\n\t->one(\$hydrate ? ".$class_name."::class : null); \n";

        $m = (new Method('readPK'))
            ->setPublic()
            ->addComment("Get informations of 1 specific ".\singular($class)." \n");
        $params = [];
        foreach ($pks As $pk)
        {
            $m->addComment('@param mixed $'.$pk);
            $params[] = new Parameter($pk);
        }
        $m->addComment('@param bool $hydrate')
            ->addComment('@return stdClass|'.$class_name.'|null')
            ->setReturnNullable()
            ->setReturnType('object')
            ->setParameters(array_merge($params, [
                (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false),
            ]))
            ->setBody($hydrate);
        $generator->addMember($m);

    	// Enregistrements avec jointures de table
        if (count($fks) > 0)
        {
            $body_method  = "return \$this->from('".$class."')";
            foreach ($fks As $fk)
            {
                $body_method .= "\n\t->join('".$fk->foreign_table_name."', ['".$class.".".$fk->column_name."' => '".$fk->foreign_table_name.".".$fk->foreign_column_name."'])";
            }
            $body_method .= "\n\t->all(\$hydrate ? ".$class_name."::class : null); \n";

            $m = (new Method('readJoin'))
                ->setPublic()
                ->addComment('@param bool $hydrate')
                ->addComment('@return stdClass[]|'.$class_name.'[]')
                ->setReturnType('array')
                ->setParameters([
                    (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false),
                ])
                ->setBody($body_method);
            $generator->addMember($m);
        }

    	// Enregistrement unique avec jointures de table
        if (count($fks) > 0)
        {
            $body_method  = "return \$this->from('$class')";
            foreach ($fks As $fk)
            {
                $body_method .= "\n\t->join('".$fk->foreign_table_name."', ['".$class.".".$fk->column_name."' => '".$fk->foreign_table_name.".".$fk->foreign_column_name."'])";
            }
            foreach ($pks As $pk)
            {
                $body_method .= "\n\t->where('".$class.".$pk', \$$pk)";
            }
            $body_method .= "\n\t->first(\$hydrate ? ".$class_name."::class : null); \n";

            $m = (new Method('readJoinPk'))
                ->setPublic();
            $params = [];
            foreach ($pks As $pk)
            {
                $m->addComment('@param mixed $'.$pk);
                $params[] = (new Parameter($pk));
            }
            $m->addComment('@param bool $hydrate')
                ->addComment('@return stdClass|'.$class_name.'|null')
                ->setReturnNullable()
                ->setReturnType('object')
                ->setParameters(array_merge($params, [
                    (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false),
                ]))
                ->setBody($body_method);
            $generator->addMember($m);
        }

    	// Enregistrements limitees
         $hydrate  = "return \$this->from('$class') \n";
         $hydrate .= "\t->limit(\$limit, \$offset) \n";
         $hydrate .= "\t->all(\$hydrate ? ".$class_name."::class : null); \n";
         $m = (new Method('readLimit'))
             ->setPublic()
             ->addComment("Select data from table ".$class." by lots \n")
             ->addComment('@param int $limit')
             ->addComment('@param int $offset')
             ->addComment('@param bool $hydrate')
             ->addComment('@return stdClass[]|'.$class_name.'[]')
             ->setReturnType('array')
             ->setParameters([
                 (new Parameter('limit'))->setType('int'),
                 (new Parameter('offset'))->setType('int')->setDefaultValue(0),
                 (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false),
             ])
             ->setBody($hydrate);
         $generator->addMember($m);

    	// Enregistrements limitees avec jointures
        if (\count($fks) > 0)
        {
            $body_method  = "return \$this->from('".$class."')";
            foreach ($fks As $fk)
            {
                $body_method .= "\n\t->join('".$fk->foreign_table_name."', ['".$class.".".$fk->column_name."' => '".$fk->foreign_table_name.".".$fk->foreign_column_name."'])";
            }
            $body_method .= "\n\t->limit(\$limit, \$offset) \n";
            $body_method .= "\t->all(\$hydrate ? ".$class_name."::class : null); \n";
            $m = (new Method('readJoinLimit'))
                ->setPublic()
                ->addComment('@param int $limit')
                ->addComment('@param int $offset')
                ->addComment('@param bool $hydrate')
                ->addComment('@return stdClass[]|'.$class_name.'[]')
                ->setReturnType('array')
                ->setParameters([
                    (new Parameter('limit'))->setType('int'),
                    (new Parameter('offset'))->setType('int')->setDefaultValue(0),
                    (new Parameter('hydrate'))->setType('bool')->setDefaultValue(false),
                ])
                ->setBody($body_method);
            $generator->addMember($m);

        }
    }

	private function addUpdateMethod(ClassType &$generator, array $variables)
    {
		/**
		 * @var string $class
		 * @var array $pks
		 */
        extract($variables);

        $hydrate  = "\$this->table('$class')";
        foreach ($pks As $pk)
        {
            $hydrate .= "\n\t->where('".$pk."', $".$pk.")";
        }
        $hydrate .= "\n\t->update(\$data); \n";
        $m = (new Method('edit'))
            ->setPublic()
            ->addComment("Set data of row in table ".$class." \n");
        $params = [];
        foreach ($pks As $pk)
        {
            $m->addComment('@param mixed $'.$pk);
            $params[] = new Parameter($pk);
        }
        $m->addComment('@param array $data')
            ->addComment('@return void')
            ->setParameters(array_merge($params, [
                (new Parameter('data'))->setType('array'),
            ]))
            ->setBody($hydrate);
        $generator->addMember($m);


        $hydrate  = "\$this->table('$class')->update(\$data); \n";
        $m = (new Method('refactor'))
            ->setPublic()
            ->addComment("Set all data in table ".$class." \n")
            ->addComment('@param array $data')
            ->addComment('@return void')
            ->setParameters([
                (new Parameter('data'))->setType('array'),
            ])
            ->setBody($hydrate);
        $generator->addMember($m);
    }

	private function addDeleteMethod(ClassType &$generator, array $variables)
    {
        \extract($variables);

        $hydrate  = "\$this->table('$class')";
        foreach ($pks As $pk)
        {
            $hydrate .= "\n\t->where('".$pk."', $".$pk.")";
        }
        $hydrate .= "\n\t->delete(); \n";
        $m = (new Method('remove'))
            ->setPublic()
            ->addComment("Delete 1 ".\singular($class)." in database \n");
        foreach ($pks As $pk)
        {
            $m->addComment('@param mixed $'.$pk)
                ->addParameter($pk);
        }
        $m->addComment('@return void')
            ->setBody($hydrate);
        $generator->addMember($m);


        $hydrate  = "\$this->table('$class')->delete(); \n";
        $m = (new Method('clear'))
            ->setPublic()
            ->addComment("Delete all items of table ".$class." \n")
            ->addComment('@return void')
            ->setBody($hydrate);
        $generator->addMember($m);
    }

    private function addCountMethod(ClassType &$generator, array $variables)
    {
        \extract($variables);

        $hydrate  = "return \$this->from('$class')->where(\$conditions)->count(); \n";
        $m = (new Method('count'.Str::toPascal($class)))
            ->setPublic()
            ->addComment("Count all rows of la table ".$class." \n")
            ->addComment('@param array $conditions')
            ->addComment('@return int')
            ->setReturnType('int')
            ->setParameters([
                (new Parameter('conditions'))->setType('array')->setDefaultValue([]),
            ])
            ->setBody($hydrate);
        $generator->addMember($m);

    }
}
